*** GCC ***

-o : target file
-c : object file, 
ar 명령: ar -crv
-I : include folder path
-L : library link folder 

소스파일 
main.c; fact.c; sum.c;

오브젝트파일
main.o; fact.o; sum.o;

실행파일

오브젝트파일이 있는 이유
통합을 해서 하나의 파일로 만들어서 프로세스를 처리하는 것보다
각각 개별로 파일을 만들어서 처리를 하는게 훨씬 쉬움(에러가능성을 더 줄여줌)

sum.c 소스파일에서 수정이 일어났을때 sum.o 파일만 수정을 하고 앞의 main.c 와 fact.c 와 같이 실행파일만 만들어내면됨

gcc main.c fact.c -o factout : using source files

gcc -c main.c fact.c
ls -al -> main.o ; fact.o
vi fact.o : containing non-readable text 
gcc main.o fact.o -o ofiles_out : using object files
 
*라이브러리들 묶기
.c .o - 파일들이 너무 많을 때 하나로 묶어주는 라이브러리

*vi main.c

#include <stdio.h>
#include "fact.h"

int main(){
	int n,f;
	printf("input number:");
	scanf("%d",&n);
	f = fact(n);
	printf("%d!=%d\n",n,f);
	return 0;
}

*vi fact.c

#include "fact.h"

int fact(int n){
          if(n==1)
	       return 1;
          else 
	       return fact(n-1)*n;

*vi fact.h

int fact(int n);

*vi sum.c
#include "sum.h"

int sum(int a, int b){
	return a+b;
}

*vi sum.h

int sum(int,int);

gcc -c main.c fact.c sum.c : 각각에 대해서 출력
한꺼번에 묶기 - gcc main.o fact.o sum.o -o out3
./out3

!이 상태에서 오브젝트 파일을 변경하고 싶을 때,
vi main.c : 여기서 변경하고
gcc -c main.c
gcc main.o fact.o sum.o -o out3
./out3 : 변경완료

라이브러리로 묶기 : ar -crv libmymath.a fact.o sum.o
라이브러리를 사용해서 컴파일하기

gcc main.c -L. -l mymath # -L. : current directory, -l : 어디에 묶여있는지 알려주는 옵션, mymath 만 쳐도됨 lib 생략가능
gcc main.c -L. -l -o out4

폴더 정리하기
mkdir lib
mkdir obj
mkdir inc
mv *.a ./lib/.
mv *.o ./obj/.
mv *.h ./inc/.

gcc main.c -I inc -L lib -l -o out4

*vi main.c

#include <stdio.h>
#include "fact.h"

int main(){
	int n,f,s;
	printf("input number:");
	scanf("%d",&n);
	f = fact(n);
	printf("%d! == %d\n",n,f);
	s = sum(n,10);
	printf("%d + 10 == %d\n",n,s);
	return 0;
}

sum.c 파일을 중간에 바꿔줬음(#include part 안써줘서) 바꿔줬을 때 다시 설정해줘야함
gcc -c sum.c -I inc -o ./obj/sum.o
ar -crv ./lib/libmymath.a ./obj/sum.o ./obj/fact.o
cd lib
ls -al : check update

* GCC & make

복잡한 gcc 옵션을 컴파일 할 때마다 지정하면 불편함
컴파일에 규칙을 만들어서 저장해놓은것이 make 파일

형태
-매크로정의
-타겟1: 의존성1-1 의존성1-2
	- 명령 1-1
	- 명령 1-2
-타겟2: 의존성 2-1 의존성 2-2
	- 명령 2-1
	- 명령 2-2

-매크로 
	- 선언: 이름=값
	- 사용: $(이름)
-주요타겟
	- all, clean, etc


vi Makefile - target 이 필요(보통 all 을 씀)

all : 	
	gcc -c fact.c -o ./obj/fact.o -I inc
	gcc -c sum.c -o ./obj/sum.o -I inc : 1개씩 따로 output 을 지정해줘야함

	아니면 

	gcc -c fact.c sum.c -I inc
	mv fact.o ./obj/.
	mv sum.o ./obj/.

sudo apt install make
make

all : 	
	gcc -c fact.c -o ./obj/fact.o -I inc
	gcc -c sum.c -o ./obj/sum.o -I inc : 1개씩 따로 output 을 지정해줘야함

	아니면 

	gcc -c fact.c sum.c -I inc
	mv fact.o ./obj/.
	mv sum.o ./obj/.

	ar -crv ./lib/libmymath.a fact.o sum.o

라이브러리 만들기
all : 	
	gcc -c fact.c -o ./obj/fact.o -I inc
	gcc -c sum.c -o ./obj/sum.o -I inc : 1개씩 따로 output 을 지정해줘야함

	아니면 

	gcc -c fact.c sum.c -I inc
	mv fact.o ./obj/.
	mv sum.o ./obj/.

	ar -crv ./lib/libmymath.a ./obj/fact.o ./obj/sum.o

라이브러리 합치고 컴파일하기
all : 	
	gcc -c fact.c -o ./obj/fact.o -I inc
	gcc -c sum.c -o ./obj/sum.o -I inc : 1개씩 따로 output 을 지정해줘야함

	아니면 

	gcc -c fact.c sum.c -I inc
	mv fact.o ./obj/.
	mv sum.o ./obj/.

	ar -crv ./lib/libmymath.a ./obj/fact.o ./obj/sum.o
	
	gcc main.c -L ./lib -I ./inc -l mymath -o out5


#이제 vi main.c 파일에서 내용을 변경하고 나서 쉽게 make 만 입력해도 업데이트된 출력이 나옴
#컴파일이 굉장히 쉬워진것

#Make 에 옵션, 타겟 넣어주기( clean: 파일 삭제 기능)
all : 	
	gcc -c fact.c -o ./obj/fact.o -I inc
	gcc -c sum.c -o ./obj/sum.o -I inc : 1개씩 따로 output 을 지정해줘야함

	아니면 

	gcc -c fact.c sum.c -I inc
	mv fact.o ./obj/.
	mv sum.o ./obj/.

	ar -crv ./lib/libmymath.a ./obj/fact.o ./obj/sum.o
	
	gcc main.c -L ./lib -I ./inc -l mymath -o out5

clean: 
	rm ./lib/*.a
	rm ./obj/*.o
	rm out

make
make clean

===========================================

out 에서 컴파일만 하고 싶을 때

all : out

out: ./lib/libmymath.a
	gcc main.c -L ./lib -I ./inc -l mymath -o out5

clean: 
	rm ./lib/*.a
	rm ./obj/*.o
	rm out

./obj/fact.o: fact.c ./inc/fact.h
	gcc -c fact.c -I inc -o ./obj/fact.o
./obj/sum.o: sum.c ./inc/sum.h
	gcc -c sum.c -I inc -o ./obj/sum.o
./lib/libmymath.a: ./obj/sum.o ./obj/fact.o
	ar -crv ./lib/libmymath.a ./obj/fact.o ./obj/sum.o


폴더 이름이 변경되었을 때
inc -> include

vi Makefile - 여기에 변수를 만들기(매크로)
INC=./include

all : out

out: ./lib/libmymath.a
	gcc main.c -L ./lib -I $(INC) -l mymath -o out5

clean: 
	rm ./lib/*.a
	rm ./obj/*.o
	rm out

./obj/fact.o: fact.c $(INC)/fact.h
	gcc -c fact.c -I $(INC) -o ./obj/fact.o
./obj/sum.o: sum.c $(INC)/sum.h
	gcc -c sum.c -I $(INC) -o ./obj/sum.o
./lib/libmymath.a: ./obj/sum.o ./obj/fact.o
	ar -crv ./lib/libmymath.a ./obj/fact.o ./obj/sum.o


*** Unix utility ***

1. wc: -c 바이트수(chracter count), -m 문자수, -l line count, -w word count
wc abc
wc -m abc
wc -w abc

2. sort: 파일정렬

sort -r abc
sort -k 2 abc
sort -n -k 2 abc

	-r: 역순정렬
	-k: 필드정렬
	-n: 숫자사용시
	-n -k: 가격을 50, 100 이 차이를 인식함


3. split: 파일분할
split -3 abc : 3줄씩 나눔 -> abc 파일만 있던게, abc b xaa xab xac 이렇게 출력됨
cat xaa 해보면 위에 3개가 들어가있음

	-b n: per n bytes
	-n: per n lines

sort abc | split -3
ls
cat xaa -> 알파벳 순으로 바뀌어 정렬되어 출력됨
sort abc | split -b 10 : 10바이트씩 분할해서 출력


4. uniq: 인접한 행이 중복된 경우 삭제

-sort와 결합해 사용
sort abc | uniq : 중복된 것들 모두 버림
sort abc | uniq -u: 중복된 행들 빼고 중복없는 행만 표시
sort abc | uniq -d: 중복된 행만 표시
sort abc | uniq -c: 중복횟수 보기

sort abc | uniq > c : 중복되는거 삭제후 c 라는 파일에 넣기
cat c

5. cut
- 필드 잘라내기
- 탭으로 필드 구분

cut -c 1-5 abc : -c n-m: 행별로 n~m번째 문자 추출
cut -f 1 abc : -f n: n번 필드 추출
who - who 등의 명령과 함께 사용
who | cut -c 1-8 -> ubuntu, ubuntu(id만 출력)
who | cut -f 1

ls -al | cut -c 1-7 -> directory authority 만 출력

6. paste - 2개의 파일 연결하기(기본적으로 필드 단위로 붙임)
paste abc weight
paste -d : abc weight // -d A: A를 필드 구분자로 추가
paste -d : c weight

중간삽입하기 - 일단 c 를 먼저 분리 - 그리고 paste 로 붙이기
cut -f 1 c >c1
cut -f 2 c >c2
cut -f 3 c >c3
cat c1
cat c2
cat c3

paste c1 weight c2 c3 - complete
paste c1 weight c2 c3 > e
cat e


7. dd
-블록 단위로 파일 복사 및 변환
dd conv=ucase if=e of=f : ucase 소문자를 대문자로
dd conv=lcase if=f of=g : lcase 대문자를 소문자로

dd bs=1024 conv=ucase if=e of=f

8. sed - 텍스트 스트림 편집, 파일들을 크기별로 sorting 하고 싶을 때

ls -al | sed 's/ubuntu/kim/g' : ubuntu 가 모두 kim 으로 바껴서 나옴
ls -al | sed 's/May/Jan/g' : May -> Jan 

ls -al | sort -k 5 : 제대로 작동하진 않음
ls -al | cut -f cut 1 : 이것도 제대로 인식되지 않음, 사이사이가 탭이 아니라 스페이스로 띄어쓰기가 되어있기 때문
ls -al | sed 's/ /_/g' : space -> underbar 처리
ls -al | sed 's/ /\t/g' : 이렇게 쓰면 스페이스가 2번 인곳은 2번 탭이 들어감, 즉 이것도 제대로 인식될수없음

이럴 때 정규표현식을 사용 - 빈칸이 반복될 때 한번만 처리

ls -al | sed -r 's/ +/_/g' : 빈칸이 1개이상인건 모두 _ 1개로 처리
ls -al | sed -r 's/ +/\t/g' : 빈칸이 1개이상인건 모두 tab 1개로 처리

ls -al | sed -r 's/ +/\t/g' | sort -k 5 : 파일 크기별로 sorting - 이것도 완벽하진 않음 -n 옵션 필요
ls -al | sed -r 's/ +/\t/g' | sort -n -k 5 
ls -al | sed -r 's/ +/\t/g' | sort -n -k 5 | more : checking






