
*** Shell 이란? ***

PUTTY 가 AWS Server(하나의 가상기계 혹은 컴퓨터라고 생각하면됨) 에 접속을 함 SSH 포트를 이용해서 접속,
접속하면 첫 화면 : ubuntu@ip-address:~/test$ : 명령어를 기다리고 있는 상태
LINUX(aws server)의 SHELL이 PUTTY 에게 이 프롬프트를 표시하라고 가르쳐준것, 
이 SHELL 은 PUTTY 가 준 명령을 받아서 (ex, ls -al), 쉘은 리눅스에게 물어보고 정보를 받아서 다시 PUTTY에게 건네줌.
이런역할은 하는것이 SHELL 이다.

*My shell type check
echo $SHELL -> /bin/bash : 내 쉘은 배시쉘을 사용중
bash --version : GNU bash, version ?.?.?

ls *(폴더안의 모든 파일도 보여줌) = ls -all = ls -al 
ls ex* : ex로 시작하는 파일,폴더들 보여줘 

*** 표준 입출력 장치 ***

#include <stdio.h> : standard, input, output

키보드에서 표준입력을 하면, 쉘은 컴퓨터에게 표준출력, 표준에러를 출력해줌
ex08 이라는 폴더가 없는데, ls ex08 이라고 명령을 주면 리눅스는 ls: cannot access 'ex08' : No such file or directory 라고 표준에러를 출력해줌

vi read.txt = vi read
질문, 확장자를 붙이는 이유 - 여러 파일들이 있을 때 사용자가 이 파일의 의미를 알기 위함. txt 면 텍스트파일이라고 유추할 수 있듯이

ls -al >out : 파일이 지워지고 대상이 되는 파일을 출력
ls -al >>out : 파일이 지워지지않고 그 아래로 덧붙여서 출력됨 즉 2번,3번 출력됨 같은내용이
ls -al ex08 > out : 메시지가 나옴 - 이건 스탠다드아웃풋이 아니라, 스탠다드에러. 
ls -al ex08 >2 out : 메시지가 안나옴, 숫자 0 : 스탠다드 인풋, 1: 스탠다드 아웃풋, 2: 스탠다드 에러

내용도 에러로, 에러도 에러로 보내는것
ls -al ex08 >out 2> out2
cat out
cat out2 - 여기만 에러로 나옴, *이 부분 이해안가면 PUTTY에서 실습해볼것.

에러 메시지 지우기
ls -al lkfjlksjfle >out 2> /dev/null : 제대로 나오는 출력은 out 으로 보내고 에러는 dev 의 null 로 보냄
ls -al lkfjlksjfle >abc 2> /dev/null : 제대로 나오는 출력은 abc 으로 보내고 에러는 dev 의 null 로 보냄(리눅스의 휴지통같은곳, 여기선 파일이 윈도우처럼 휴지통에 남아있지않음)

입력 
cat < out : out 의 내용을 cat에 갖다주는것

*** ubuntu@ip-address ***
프롬프트 앞에 나오는 거 환경변수 설정으로 변경하기

*파이프라인(pipeline) - |
프로그램 A 에서 명령을 한 뒤 나오는 결과 -> 모니터로 가져와서 출력 : 이걸 중간에서 강탈해서 프로그램 B 로 보냄,
A 의 결과를 B 로 보내는 명령 - 이걸 파이프라인이라고 함, 

set | more : 쉘변수를 보여줌
env | more : 환경변수를 보여줌
Windows 의 환경변수 : 내PC-속성-고급시스템설정-환경변수-path : path에 들어가있으면 어디서 찾든 파일,폴더 탐색가능

환경변수의 종류 : 대부분 대문자로 표시되어 있음
USER, PWD, HOME, SHELL, SSH, MAIL, PATH.. etc

echo home -> home
echo $HOME -> /home/ubuntu

$CDPATH setting
내가 자주쓰는 폴더를 CDPATH 로 넣기 이렇게 되면 어디위치에서든 이동가능함

CDPATH=/home/ubuntu (= 앞뒤로 띄어쓰기 ㄴㄴ)
echo $CDPATH -> /home/ubuntu
export CDPATH 
set | more : 여기에 CDPATH 저장되어 있음
env | more : 여기에 CDPATH 저장되어 있음

*** CTRL + 단축키 ***

stty -a : ctrl + 단축키 명령어들 알려줌
ctrl + ?/ : erase
ctrl + D : eof
ctrl + 

*** Alias (가명) *** 
명령을 할 때 긴 명령을 간단하게 만들어서 처리하는것을 말함.

alias elementary setting 
ls ='ls --color=auto'
l ='ls -CF'

alias c=clear : new alias add, short typing 
alias ls=ls : without color, difficulty in distinguishing folders and files
alias ls='ls --color=auto' : '' neccessity

파일이나 폴더를 지울 때 안전하게 옵션넣기
rm -i out -> file 'out' y? : -i 지울지 말지 물어봐주는 옵션
alias rm='rm -i'

가명을 없애고 싶을 때,
unalias rm
unalias c

*function 사용
function mycd { cd $1;pwd } : $1 - 1st parameter is cd
set | more
mycd () - check 

*이전에 실행한 명령들이 저장되어 있는 history check
ls -al
ls .bash_history
vi .bash_history 
fc 
fc -l 1100 : 1100 번 명령부터 끝까지 명령한거 보여줌
!! : 제일 마지막에 실행한거 재실행
!v : 최근실행한 명령중에서 v로 시작하는 명령을 찾아서 실행함
!func : function 명령 최근에 실행한거 재실행

*** prompt setting ***

ubuntu@ip-address:~$
echo $PS1
copy paste - mouth right button

PS1='TEST> '
TEST>  가 프롬프트로 나옴
PS1='$USER@$PWD> '
PS1='\u@$PWD> '
PS1='\w> ' : 절대경로
PS1='\t$PWD> ' : time - based on server
PS1='\a$PWD> ' 
PS1='\!> ' : history number

*color prompt

PS1='\[\e[31;37;5m\]$PWD> ' : e[글자색, 배경색, 굵기], prompt area 의 색상도 바뀌므로 이상해짐.
PS1='\[\e[36;40;1m\]$PWD \[\e[37;40;0m\]> ' : blue color

*환경설정 반영구적으로 저장해놓기

login 할 때 자동으로 내가 만들어놓은걸 불러오기
.bashrc, .profile 이 로그인시에 실행됨
vi .profile : running bachrc 
vi .bashrc : 대부분의 경우가 여기에 들어가있음, 쉘 실행마다 반복적으로 실행됨

vi .bashrc 
if color_prompt = yes, this part.

#if
#else
#
#
#fi

PS1='\[\e[36;40;1m\]$PWD \[\e[37;40;0m\]> ' 

이렇게 저장하면, 앞으로 내가 설정한 prompt format 이 나오게 됨

*** 접근 권한 ***
approach authority

ls -al
. - current folder
.. - upper folder
drwxrxr-x - d(directory)
3, 2 - 이런 숫자들, 링크임
directory 같은 경우는 2 가 default, 자신, 부모폴더
ubuntu ubuntu : 1st ubuntu (이 파일의 주인), 2nd ubuntu (이 파일의 그룹)

권한 바꾸기 - chmod u+r test

*기호를 이용한 권한변경
vi hello.c
#include <stdio.h>
int main(){
	printf("hello world!");
	return 0;
}

ls -all

gcc : unix, linux 에서 쓰는 컴파일러 

sudo apt install gcc
gcc hello.c 
ls -all -> a.out 이라는 실행파일이 새로 생성됨
./a.out : 현재 폴더에 있는 a.out 을 실행시켜라

*실행권한 없애기
chmod u-x a.out
ls -al
./a.out -> Permission denied

*다시 실행권한 주기
chmod u+x a.out
./a.out -> work!

summary : chmod [r/w/x][-/+][file/folder name]


*숫자를 이용한 권한변경
rwx(소유자, 그룹, 기타사용자) - 4,2,1 : 400(소유자에게만 권한 줌), 420(소유자, 그룹에게 권한 줌) 
7 모든 사용자 권한, 5 부분 권한, 0 모두 권한 X 

chmod 750 test 
chmod 000 test : 모든 사용자 권한 없음
ls -al

umask -> 0002
umask 000
umask 007

*사용자변경, 그룹변경
ubuntu 사용자 변경 

sudo chown root a.out - 루트 권한으로 실행
ls -al 
chmod 707 a.out - operation not permitted
sudo chmod 707 a.out - working!

vi hello.c
sudo chgrp root hello.c

그룹이 달라지면서 파일을 읽을수가 없게됨, 그룹과 사용자가 다르므로 파일 읽기까지 불가능해짐
 

*** grep 과 정규표현식 ***

sudo chown ubuntu *
sudo chgrp ubuntu * -R : 하위 폴더 까지 모두 변환
chmod 755 * -R
ls -al 해보면 전체적으로 다 바뀌었지만 .filenames 로 시작하는 애들은 안바뀜

왜냐면 전체를 다 바꾸라는건 
chmod 755 .* -R : 근데 이건 operation not permitted 라고 나옴
이 경우엔, chmod 755 ubuntu/ -R 이라고 하면됨
cd ubuntu/
ls -all : 모두 다 바뀌어있음

======================

ls -al > list
vi list 
grep abc list : abc 가 들어가 있는 줄만 따로 뽑아줘
grep a list : a 가 들어가 있는 줄만 따로 뽑아줘

env | grep home
set | grep PS1

정규표현식 : 복잡한 문장이나 문자열을 간단하게 표현하기 위한 방법

ex)
나는 짜장면 먹을래
나는 짜장면
나 짜장면
나 짜장
짜장

(나는?)? 짜장면 (먹을래)?

abc
adc
aec

a-> 아무거나 1글자 -> c 
a_c included

ls | grep 'a[a-z]c' : result - abc.txt , adc
ls | grep 'a[a-zA-Z]c'
aBc
abc.txt
adc

ls | grep 'a[0-9]c' : a 와 c 사이에 0-9 사이의 숫자
ls | grep 'a[^A-Z]c' : ^ - 부정, 대문자 A-Z 까지 안들어가는 파일만 출력해줘
ls | grep 'a[^a-z]c' : 소문자 a-z 까지 안들어가는 파일만 출력해줘

egrep : grep 의 확장
fgrep : 파일에서 검색하기 (regex 무시)

** regexper.com ** : 정규표현식 시각적으로 이해시켜주는 사이트

He?llo 
- Hello, Hllo 2개의 의미를 가짐

Hi, [a-z]*$  
$ : end of line 
^ : start of line
* : repeat 

m\.(naver|daum|google)\.com
^m\.(naver|daum|google)\.com$ : m 앞에 뭐가 들어오면 안돼, com 뒤에도 뭐가 들어오면 안돼!

PuTTY 에서 실습

vi practice
www.naver.com 네이버
www.apple.com 애플
www.tesla.com 테슬라
www.google.com 구글
www.toss.co.im 토스
www.daum.net 다음

cat practice
more practice | grep com 
more practice | grep co

cat practice | grep naver
cat practice | egrep '(naver|daum)' (e: extended)

#
naver.com 
naver2com 이렇게 있을 때 naver.com 만 가져오고 싶을 땐

cat practice | egrep '(naver|daum)\.com'
cat practice | egrep '(naver|daum).com' : 이렇게만 쓰면 . 의 정규표현 의미가 아무글자나 하나 이므로 - naver2com 도 가져오게됨

vi novel
cat novel | egrep 'fire'
cat novel | egrep 'the' | more : more 의 기능은 차례대로 1페이지씩 순차적으로 보여줌

파일/디렉토리 관련된 다른 명령들

find
- 파일검색
- options: -type(d,f,l, ....), - mtime(modi time), -atime(access time), -newer, -exec, -ok

find ~ abc.txt - 파일을 검색하는 모든 폴더를 다 출력하면서 찾는걸 보여줌, 즉 쓸데없는 파일들도 출력해줌
find ~ -name abc.txt - 찾은 파일들만 보여줌

which
- 명령어의 위치

whereis
- 명령어의 위치, 소스위치, man파일 위치

*유닉스 시스템에서는 같은 폴더내에서 같은 이름으로 파일이나 디렉토리를 만들수 없음

find ~ -name novel -type d - directory
find ~ -name novel -type f - file
find ~ -name novel -ls : showing detail information

cp t.txt ex02/.
find ~ -name t.txt -mtime -8 -ls : 24시간*8일 현재에서 과거시점으로, 즉 현재부터 8일전까지 만들어진 파일들
find ~ -name t.txt -mtime 8 -ls : 24시간 * n : 현재부터 8-9일 전 사이에 만들어진 파일들
find ~ -name t.txt -mtime +8 -ls : 24시간 * (n+1) : 9일전부터 과거까지에 만들어진 파일들

which ls
which vi

whereis vi
vi: /usr/bin/vi /usr/share/man/man1/vi.1.gz
man vi

find ~ -name abc.txt > result : 이건 파이프라인아님, 헷갈리지 말기. 뒤쪽에 나오는 result 라는 파일에 앞쪽에 나오는 결과를 저장해주는 명령
cat result

==================================


*** 파일압축, FTP ***

1. tar - cvf, tvf, xvf, uvf  ; tar 는 압축을 전혀 안함

tar -cvf a.txt.tar a.txt
tar -cvf we10 *
tar -tvf we10
ls -al

tar -xvf we10 : 압축풀기
rm we10
tar -cvf we10.tar *
tar -tvf we10.tar

tar -xvf we10.tar = tar -xv < we10.tar

* -C 옵션
mkdir new
tar -xvf we10.tar -C new : new 라는 폴더에 압축을 풀어줘

2. jar(basis on java) - cvf, tvf, xvf,uvf ; jar 는 압축을 함
sudo apt install default-jdk

tar -cvf we10.tar we10
tar -tvf we10.tar
jar -cvf we10.jar we10
ls -al we10.tar
ls -al we10.jar

3. compress - compress,uncompress
sudo apt install ncompress

compress a.txt -> a.txt.Z (압축)
uncompress a.txt : 압축풀기

compress we10.tar
uncompress we10.tar.Z
jar 랑 비교해보면 compress 가 압축을 훨씬 더 많이함 

압축 옵션
compress -v we10.tar : v(view information of file

Z 파일 미리보기 기능
cat a.txt.Z (x)
zcat a.txt.Z (o)

4. gzip -r : directory, -l : check information, gunzip, tar -z

gzip a.txt - 압축
gunzip a.txt.gz - 압축풀기

gzip we10.tar : 389 byte
gzip -9 we10.tar : -9 옵션은 최대한 압축을 해보자 - 355 byte
 
여러개의 파일들을 한번에 압축을 시키기
tar 로 여러개의 파일들을 먼저 묶기 -> gzip 을 이용해서 tar 파일을 압축하기


5. zip -v,-r,-d
sudo apt install zip

zip -r we10.zip we10
unzip we10.zip

6. bz2 --best, bunzip2, bzcat
bzip2 we10.tar

bzcat a.txt.bz2 : read bz2 file
bunzip2 a.txt.bz2 

*프로세스(process) : OS에서 실행중인 프로그램 - ctrl + shift + esc key button
프로그램 vs 프로세스 : PuTTY 를 실행하고 또 열면, 프로그램은 1개인데 프로세스는 2개인 것
프로세스의 종류
- 데몬 프로세스 : 윈도우에서 자체적으로 실행시켜놓은 프로세스들
- 부모 프로세스 : 
- 고아 프로세스 : 부모 프로세스를 종료시키면, 자식 프로세스는 순간적으로 고아가되는것 - 시스템 프로세스로 자동으로
연결되어서, 쉽게 이해해보면 할아버지가 부모 프로세스로 연결됨.
- 좀비 프로세스 : 자식 프로세스가 보통 종료되는게 일반적인데, 죽을 때 부모 프로세스에게 알려줘야하는데
알려주지 않고 문제가 있는 상태라 종료가 된다면, 정보가 애매하게 남아있는 상태로 좀비 프로세스가 됨(사람은 죽었는데
사망 처리가 되어 있지 않은것) , 좀비 프로세스가 많을수록 시스템에 문제가 생김.



PuTTY 에서 ps
ps -e : linux process 들을 보여줌
ps -e | more
? - 로 나오는 프로세스들은 데몬 프로세스
pts/1 - 우리가 실행한 프로세스들
ps -u ubuntu : 특정사용자에 대한 프로세스만 볼려고 할 때
ps -u ubuntu -f : 좀 더 자세한 정보를 나타냄

linux 에서 강제종료 기능 : kill
sleep 100 : 100초 동안 잠자기
ps -u ubuntu - 에서 확인해보면 sleep 기능이 추가되어있음
kill -15 48130 : sleep 기능 종료시키기, -15는 약한 강제종료, -9 강한 강제종료 


*TOP 명령
top : 다양한 프로세스들 확인가능


foreground vs background 작업

sleep 100
^c (ctrl + c - 강제 종료)

sleep 100 & - background 에서 running

vi hello.c
#include <stdio.h>
#include <unistd.h>
int main(){
	int i;
	for(i=0; i<10000; i++){
		print("Hi, Kevin!\n");
		usleep(1000000);
	}
	return 0;
}

gcc hello.c
./a.out
./a.out & - background 에서 돌아가고 있는 것이므로, 계속 컴파일은 실행되지만 다른 명령을 줄 수 있음
^c 로 종료 안됨
kill -9 48256 로 강제 종료해야함

백그라운드를 이용해서 컴파일하고 다 동작하면 output 에 저장.
./a.out > output
cat output 




*FTP
파일을 주고 받는데에 있어서 최적화된 서비스
웹서버에서는 파일을 보통 받기만 하지 보내고 받는 경우는 드뭄, FTP에서는 파일을 주고받음(보안은 로그인으로 해결)

AWS 에서 FTP 서버의 설치와 활용

ftp program install
sudo apt install vsftpd

setting check
whereis vsftpd
cd /etc
ls vs*
sudo vi vsftpd.conf
anonymous_enable=NO - 꼭 확인할 것

알ftp download
ALDrive - 사이트맵 - ftp 파일에 파일추가 - SFPT(SSH file transfer protocol), 포트 22 - 
- 호스트: 웹서버 주소, IPv4 Public IP  - ID: ubuntu - 고급설정, 공개키인증 - 개인키인증 파일 (PuTTY 접속용 키 파일, pem file) -
- 연결버튼 클릭

이 부분 다시 복습할 것 html 을 연결해서 ftp 로 파일 수정하는것











